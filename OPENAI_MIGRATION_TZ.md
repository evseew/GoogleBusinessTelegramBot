## ТЗ: Переход на OpenAI Responses + Conversations API

Коротко: уходим от устаревающих Threads/Runs (Assistants) к Responses/Conversations. Контекст и эмбеддинги остаются. Включение нового пути — фичефлагом, для безопасного rollout/rollback.

### Вариант реализации (нужно выбрать)
- Вариант A — минимальный: `responses.create` + ожидание результата (polling). Быстро внедрить. Задержка ответа обычная.
- Вариант B — рекомендуемый: `responses.create` + стриминг событий. Ответ приходит быстрее, код чище. Чуть больше правок.
- Вариант C — гибрид: интерфейс над LLM и фичефлаг (старый/новый путь параллельно). Самый безопасный rollout, немного больше работ.

Укажите выбранный вариант (A/B/C) перед стартом разработки.

---

## Шаг 1. Подготовка окружения
- Обновить библиотеку `openai` до актуальной 1.x в `requirements.txt`.
  - Зачем: новая API доступна только в современных версиях клиента.
- Добавить ENV-переменную `USE_OPENAI_RESPONSES=true|false` (по умолчанию false) и, при необходимости, `ASSISTANT_ID` (v2) либо подтвердить совместимость текущего `ASSISTANT_ID`.
  - Зачем: управляемое включение новой логики и стабильная ссылка на ассистента.

Артефакты: обновлённый `requirements.txt`, описание переменных в `README.md`.

## Шаг 2. Модель идентификаторов диалогов
- Переименовать/заменить хранение `user_threads: Dict[int, str]` → `user_conversations: Dict[int, str]`.
- Файл `user_threads.json` заменить на `user_conversations.json`. Реализовать авто-миграцию при старте (если есть старый файл — создать новый пустой, контекст начнётся с чистого разговора).
  - Зачем: новый API оперирует `conversation_id`, а не `thread_id`. Проще начать новые разговоры, чем «переносить» несовместимые thread.

Артефакты: новая структура в памяти и новый файл хранения соответствий.

## Шаг 3. Создание/получение диалога (Conversations)
- Заменить `get_or_create_thread(user_id)` → `get_or_create_conversation(user_id)`:
  - Если есть `conversation_id` в `user_conversations` — опционально проверять доступ/существование.
  - Если нет — создавать новый conversation и сохранять id.
  - Зачем: обеспечить непрерывный контекст для каждого пользователя на новом API.

Артефакты: новая функция получения/создания conversation.

## Шаг 4. Отправка запроса и получение ответа (Responses)
- В `chat_with_assistant(...)` заменить связку:
  - `threads.messages.create(...)` + `runs.create(...)` + `runs.retrieve/list/cancel(...)`
  - НА: один вызов `responses.create(assistant_id=..., conversation=..., input=[{role:"user", content: full_prompt}])`.
- Вариант A: ожидать финальный ответ через `responses.retrieve(...)`/готовый `response`.
- Вариант B: использовать стриминг событий и собирать текстовый ответ по чанкам.
  - Зачем: упростить логику, избавиться от гонок и подвисаний с runs, ускорить доставку ответа (в B).

Артефакты: обновлённая функция `chat_with_assistant`, извлечение `response_id` и текста ответа.

## Шаг 5. Реплей истории в новый диалог
- Заменить `replay_history_to_thread(...)` → `replay_history_to_conversation(...)`.
- Для каждого исторического сообщения использовать `conversations.messages.create(...)` (role: user/assistant).
  - Зачем: прогреть контекст, если у пользователя создаётся новый conversation.

Артефакты: обновлённая функция реплея истории.

## Шаг 6. Логирование и метрики
- Во всех логах заменить `thread_id/run_id` на `conversation_id/response_id`.
- Добавить метки времени: t0 (create response) → tN (получен финал/stream end) для оценки латентности.
  - Зачем: прозрачная диагностика и контроль производительности после миграции.

Артефакты: расширенные логи в `logs/`.

## Шаг 7. Обработка ошибок и ретраи
- Обновить перехват исключений на новые типы клиента 1.x (`openai.APIError`, сетевые ошибки и т.д.).
- Сохранить 1 повторную попытку с небольшим backoff; убрать отмену `run` (больше не нужна).
  - Зачем: устойчивость к временным сбоям и упрощение кода.

Артефакты: упрощённые ретраи без `runs.cancel`.

## Шаг 8. Эмбеддинги и база знаний
- Эмбеддинги оставляем как есть (`embeddings.create`), модель и `dimensions` проверяем на поддерживаемость текущей версией.
  - Зачем: не ломать поиск контекста и качество ответов.

Артефакты: без изменений бизнес-логики ChromaDB.

## Шаг 9. Тесты
- Юнит: `get_or_create_conversation` — создаёт и возвращает корректный `conversation_id`.
- Юнит: `chat_with_assistant` — возвращает текст при валидном ответе, корректно обрабатывает таймаут/ошибки.
- Интеграция: короткий диалог (2–3 сообщения) — контекст сохраняется, ответ релевантен.
- Нагрузочный смоук: 5 параллельных пользователей — нет утечек/пересечений контекста.
  - Зачем: подтвердить корректность и стабильность после миграции.

Артефакты: тест-кейсы, отчёт запуска (manual или авто, по возможностям проекта).

## Шаг 10. Rollout и фичефлаг
- Этап 1: включить `USE_OPENAI_RESPONSES=true` для тестового аккаунта/окружения.
- Этап 2 (canary): включить для части пользователей (например, по хешу user_id).
- Этап 3: включить для всех; наблюдать логи/метрики 1–2 недели.
  - Зачем: безопасное внедрение и быстрый откат при проблемах (переключением флага).

Артефакты: план включения/отката, инструкции в `README.md`.

## Шаг 11. Удаление legacy
- После успешной стабилизации удалить все вызовы `beta.threads.*` и `runs.*`, вспомогательные функции под Assistants.
  - Зачем: снизить техдолг и упростить сопровождение.

Артефакты: чистый код без зависимостей от Threads/Runs.

---

### Критерии приёмки
- При `USE_OPENAI_RESPONSES=true`:
  - Бот стабильно отвечает, контекст сохранён между сообщениями.
  - В коде отсутствуют вызовы `beta.threads.*`/`runs.*` (проверка по grep).
  - В логах присутствуют `conversation_id` и `response_id`.
  - Тесты (юнит/интеграция) проходят.
- При `USE_OPENAI_RESPONSES=false`:
  - Старый путь не деградирует (до удаления legacy).

### Риски и меры
- Изменение формата вывода: нормализовать текст ответа (в стриме собирать по чанкам).
- Лимиты/временные ошибки: backoff и 1 ретрай.
- Исторические треды несовместимы: начать новые conversations; при необходимости дослать краткую историю.

### Файлы, которые изменятся
- `bot.py`: переход на Conversations/Responses, логи/ошибки, переименование структур.
- `requirements.txt`: версия `openai` 1.x.
- `README.md`: переменные окружения и порядок включения фичефлага.
- Новый: `user_conversations.json` (runtime), авто-миграция со старого файла.

---

Примечания по реализации
- Вариант A — проще начать (polling), затем можно доработать до стрима.
- Вариант B — сразу «правильно» и быстрее для пользователя.
- Вариант C — рационален, если нужен безболезненный откат в проде.

После выбора варианта (A/B/C) подготовлю детальные правки по функциям `bot.py` с указанием точек замены и сигнатур вызовов клиента OpenAI.



